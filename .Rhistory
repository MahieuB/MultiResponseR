colnames(mat.eig)=c("eigenvalue","percentage of inertia")
name.dim=paste("Dim.",1:nrow(mat.eig))
rownames(mat.eig)=colnames(col.coord)=colnames(row.coord)=name.dim
if(!is.null(proj.row)){
colnames(proj.row.coord)=name.dim
}else{
proj.row.coord=NULL
}
if(!is.null(proj.col)){
colnames(proj.col.coord)=name.dim
}else{
proj.col.coord=NULL
}
colnames(u)=name.dim
names(vs)=name.dim
colnames(v)=name.dim
if (ellipse){
row.coord=row.coord[,1:nbaxes.proc]
col.coord=col.coord[,1:nbaxes.proc]
if(!is.null(proj.row)){
proj.row.coord=proj.row.coord[,1:nbaxes.proc]
}
if(!is.null(proj.col)){
proj.col.coord=proj.col.coord[,1:nbaxes.proc]
}
registerDoParallel(cores = ncores)
nboot=nboot
sortie <- foreach(icount(nboot), .combine='rbind') %dopar% {
vec.ligne=NULL
for (boot.cat in levels(data$cat)){
les.ligne=which(data$cat==boot.cat)
loto=sample(les.ligne,length(les.ligne),replace = TRUE)
vec.ligne=c(vec.ligne,loto)
}
jdd.tirage=data[vec.ligne,]
rownames(jdd.tirage)=as.character(1:nrow(jdd.tirage))
nplus.tirage=table(jdd.tirage$cat)
nom.cat=names(nplus.tirage)
nplus.tirage=as.numeric(nplus.tirage)
names(nplus.tirage)=nom.cat
cont.tirage = aggregate(.~cat,jdd.tirage,sum)
rownames(cont.tirage)=as.character(cont.tirage$cat)
cont.tirage$cat=NULL
redui.tirage=cont.tirage
verif=colSums(cont.tirage)
vire = which(verif==0)
if(length(vire)!=0){
cont.tirage=cont.tirage[,-vire]
redui.tirage=redui.tirage[,-vire]
}
######
procrustes <- function(amat, target, orthogonal = FALSE,
translate = FALSE, magnify = FALSE) {
for (i in nrow(amat):1) {
if (any(is.na(amat)[i, ]) | any(is.na(target)[i,
])) {
amat <- amat[-i, ]
target <- target[-i, ]
}
}
dA <- dim(amat)
dX <- dim(target)
if (length(dA) != 2 || length(dX) != 2)
stop("arguments amat and target must be matrices")
if (any(dA != dX))
stop("dimensions of amat and target must match")
if (length(attr(amat, "tmat")))
stop("oblique loadings matrix not allowed for amat")
if (orthogonal) {
if (translate) {
p <- dX[1]
target.m <- (rep(1/p, p) %*% target)[, ]
amat.m <- (rep(1/p, p) %*% amat)[, ]
target.c <- scale(target, center = target.m,
scale = FALSE)
amat.c <- scale(amat, center = amat.m, scale = FALSE)
j <- svd(crossprod(target.c, amat.c))
}
else {
amat.c <- amat
j <- svd(crossprod(target, amat))
}
rot <- j$v %*% t(j$u)
if (magnify)
beta <- sum(j$d)/sum(amat.c^2)
else beta <- 1
B <- beta * amat.c %*% rot
if (translate)
B <- B + rep(as.vector(target.m), rep.int(p,
dX[2]))
value <- list(rmat = B, tmat = rot, magnify = beta)
if (translate)
value$translate <- target.m - (rot %*% amat.m)[,
]
}
else {
b <- solve(amat, target)
gamma <- sqrt(diag(solve(crossprod(b))))
rot <- b * rep(gamma, rep.int(dim(b)[1], length(gamma)))
B <- amat %*% rot
fcor <- solve(crossprod(rot))
value <- list(rmat = B, tmat = rot, correlation = fcor)
}
return(value)
}
nplusplus.tirage=sum(nplus.tirage)
fij.tirage=(nplus.tirage%o%colSums(redui.tirage))/nplusplus.tirage
std.tirage=((redui.tirage-fij.tirage)/sqrt(fij.tirage))/sqrt(nplusplus.tirage)
n.tirage=nrow(redui.tirage)
p.tirage=ncol(redui.tirage)
nb.axe.tirage=min(n.tirage-1,p.tirage)
udv.tirage=svd(std.tirage)
u.tirage=udv.tirage$u[,1:nb.axe.tirage]
vs.tirage=udv.tirage$d[1:nb.axe.tirage]
rownames(u.tirage)=rownames(redui.tirage)
marge.r.tirage=nplus.tirage/nplusplus.tirage
row.coord.tirage=(u.tirage/sqrt(marge.r.tirage))%*%diag(vs.tirage)
row.coord.tirage=row.coord.tirage[,1:nbaxes.proc]
######
rot = procrustes(row.coord.tirage, row.coord, orthogonal = T, translate = T, magnify = F)$rmat
rot=cbind.data.frame(rownames(rot),rot)
colnames(rot)[1]="cat"
return(rot)
}
sortie$cat=as.factor(sortie$cat)
toellipse=sortie
rownames(toellipse)=as.character(1:nrow(toellipse))
centre=row.coord[,1:nbaxes.proc]
centre=cbind(as.data.frame(rownames(centre)),centre)
colnames(centre)=colnames(toellipse)
rownames(centre)=as.character(1:nrow(centre))
deltapos=centre
deltapos[,2:ncol(deltapos)]=deltapos[,2:ncol(deltapos)]-aggregate(.~cat,toellipse,mean)[,2:ncol(deltapos)]
for (p.delta in unique(toellipse$cat)){
choix.ligne=rownames(toellipse[toellipse$cat==p.delta,])
choix.vec=deltapos[deltapos$cat==p.delta,][,2:ncol(deltapos)]
choix.vec.dup=as.data.frame(as.matrix(rep(1,nboot))%*%as.matrix(choix.vec))
toellipse[choix.ligne,2:ncol(toellipse)]=toellipse[choix.ligne,2:ncol(toellipse)]+choix.vec.dup
}
toellipse$cat=as.factor(toellipse$cat)
centre$cat=as.factor(centre$cat)
coord.boot=toellipse[,1:(nbaxes.sig+1)]
dim.sig=nbaxes.sig
les.prod=unique(coord.boot$cat)
diff.test=as.data.frame(matrix(1,length(les.prod),length(les.prod)))
colnames(diff.test)=rownames(diff.test)=les.prod
for(i in 1:nrow(diff.test)){
for (j in 1:ncol(diff.test)){
if (dim.sig > 1){
if (i != j){
p.1=rownames(diff.test)[i]
p.2=colnames(diff.test)[j]
don.coord=coord.boot[coord.boot$cat==p.1 | coord.boot$cat==p.2,]
don.coord$cat=as.factor(as.character(don.coord$cat))
mod.man=lm(as.matrix(don.coord[,2:ncol(don.coord)])~cat,don.coord)
res.can=candisc(mod.man,"cat",type = "3")
proj.coord=res.can$scores
X=proj.coord[proj.coord$cat==p.1,]
Y=proj.coord[proj.coord$cat==p.2,]
X$cat=Y$cat=NULL
Z=round(X-Y,12)
gauche=length(which(Z<=0))
droite=length(which(Z>=0))
pvalue.test=((min(gauche,droite)+1)/(nboot+1))*2
if (pvalue.test>1){
pvalue.test=1
}
diff.test[p.1,p.2]=pvalue.test
}
}
if (dim.sig==1){
if (i != j){
p.1=rownames(diff.test)[i]
p.2=colnames(diff.test)[j]
don.coord=coord.boot[coord.boot$cat==p.1 | coord.boot$cat==p.2,]
don.coord$cat=as.factor(as.character(don.coord$cat))
X=don.coord[don.coord$cat==p.1,]
Y=don.coord[don.coord$cat==p.2,]
X$cat=Y$cat=NULL
Z=round(X-Y,12)
gauche=length(which(Z<=0))
droite=length(which(Z>=0))
pvalue.test=((min(gauche,droite)+1)/(nboot+1))*2
if (pvalue.test>1){
pvalue.test=1
}
diff.test[p.1,p.2]=pvalue.test
}
}
}
}
}else{
toellipse=NULL
diff.test=NULL
}
back=list(eigen=mat.eig,row.coord=row.coord,col.coord=col.coord,proj.row.coord=proj.row.coord,proj.col.coord=proj.col.coord,svd=list(u=u,vs=vs,v=v),bootstrap.replicate.coord=toellipse,total.bootstrap.test.pvalues=diff.test)
?MCA
353-16
400-63
library(MultiResponseR)
?mrCA
library(MultiResponseR)
?mrCA
library(MultiResponseR)
?mrCA
library(MultiResponseR)
?mrCA
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
res=mrCA(dset)
res
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
res=mrCA(dset,ellipse = T)
res$total.bootstrap.test.pvalues
library(MultiResponseR)
?plt
?plt.mr.sig.cell
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
parallel::detectCores()
res=mr.sig.cell(dset,ncores = 8)
plt.mr.sig.cell(res)
res$p.value
data(milkchoc)
parallel::detectCores()
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=4,ncores=8)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
?plot
?points
?min
require(MultiResponseR)
?mrCA
?sensory.mrCA
library(MultiResponseR)
?plt.mrCA
library(MultiResponseR)
?plt.mrCA
data(milkchoc)
parallel::detectCores()
dim.sig=sensory.mr.dimensionality.test(milkchoc)$dim.sig
res=sensory.mrCA(milkchoc,nbaxes.sig=dim.sig)
plt.mrCA(res)
?plt.mrCA
plt.mrCA(res,axes=c(3,2))
plt.mrCA(res,axes=c(3,4))
dim.sig
res$total.bootstrap.test.pvalues
plt.mrCA(res,axes=c(1,2))
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
parallel::detectCores()
res=mrCA(dset)
plt.mrCA(res)
res=mrCA(dset,ellipse = TRUE)
plt.mrCA(res)
mr.dimensionality.test(dset,ncores = 8)
plt.mrCA(res,axes=c(1,2))
plt.mrCA(res,axes=c(3,4))
plt.mrCA(res,axes=c(1,2))
res$bootstrap.replicate.coord
plt.mrCA(res,axes=c(3,4))
library(MultiResponseR)
require(MultiResponseR)
?milkchoc
data(milkchoc)
milkchoc
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
?sensory.mr.sig.cell
?mr.sig.cell
library(MultiResponseR)
?plt.mrCA
library(MultiResponseR)
?milkchoc
?plt.mr.sig.cell
# non-sensory example
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
parallel::detectCores()
res=mr.sig.cell(dset)
res
plt.mr.sig.cell(res)
plt.mr.sig.cell(res,choice="p")
plt.mr.sig.cell(res,choice="p.value")
?sensory.mr.sig.cell
?mr.sig.cell
library(MultiResponseR)
require(MultiResponseR)
?mr.dimensionality.test
library(MultiResponseR)
2+2
library(MultiResponseR)
library(MultiResponseR)
?plt.mr.sig.cell
library(MultiResponseR)
?plt.mr.sig.cell
library(MultiResponseR)
library(MultiResponseR)
library(MultiResponseR)
?sensory.overall.analysis
?sensory.overall.analysis
library(MultiResponseR)
library(MultiResponseR)
?sensory.overall.analysis
data(milkchoc)
parallel::detectCores()
sensory.overall.analysis(milkchoc,ncores = 8)
library(MultiResponseR)
?sensory.mr.sig.cell
library(MultiResponseR)
?sensory.mr.sig.cell
library(MultiResponseR)
2+2
require(devtools)
?install_github
?install_github
require(MultiResponseR)
?vignette
vignette("MultiResponseR")
devtools::install_github("MargotBr/BinQmet", build_vignettes = TRUE)
install.packages("tibble")
install.packages("tibble")
install.packages("tibble")
## Not run: edit(v1) # e.g., to send lines ...
}# if( has vignette "installed")
## A package can have more than one vignette (package grid has several):
vignette(package = "grid")
if(interactive()) {
## vignette("rotated")
## The same, but without searching for it:
vignette("rotated", package = "grid")
}
install.packages("FactoMineR")
2+5
require(FactoMineR)
?CA
res.ca <- CA (children, row.sup = 15:18, col.sup = 6:8)
data(children)
res.ca <- CA (children, row.sup = 15:18, col.sup = 6:8)
library(MultiResponseR)
?plt.mrCA
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
parallel::detectCores()
res=mrCA(dset)
plt.mrCA(res)
plt.mrCA(res,expansion = 2)
library(MultiResponseR)
1+1
library(MultiResponseR)
library(MultiResponseR)
?milkchoc
?MultiResponseR
usethis::use_package_doc()
library(MultiResponseR)
?MultiResponseR
usethis::use_package_doc()
library(MultiResponseR)
?MultiResponseR
??MultiResponseR
usethis::use_package_doc()
?usethis::use_package_doc
?devtools::document
library(MultiResponseR)
?Multinomial
?devtools::document("MultiResponseR")
devtools::document("MultiResponseR")
devtools::document()
devtools::document()
library(MultiResponseR)
?usethis::use_package_doc
usethis::use_package_doc()
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
library(MultiResponseR)
library(MultiResponseR)
?mrCA
library(MultiResponseR)
library(MultiResponseR)
?mrCA
nb.obs=200
nb.response=5
nb.category=5
vec.category=paste("C",1:nb.category,sep="")
right=matrix(rbinom(nb.response*nb.obs,1,0.25),nb.obs,nb.response)
category=sample(vec.category,nb.obs,replace = TRUE)
dset=cbind.data.frame(category,right)
dset$category=as.factor(dset$category)
res=mrCA(dset)
plt.mrCA(res)
library(MultiResponseR)
library(MultiResponseR)
require(MultiResponseR)
?sensory.mr.sig.cell
data(milkchoc)
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=1,ncores = 8)
library(MultiResponseR)
?sensory.mr.sig.cell
data(milkchoc)
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=1,ncores = 8)
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=2,ncores = 8)
library(MultiResponseR)
library(MultiResponseR)
data(milkchoc)
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=1,ncores = 8)
plt.mr.sig.cell(es)
plt.mr.sig.cell(res)
ac=mrCA(milkchoc[,-1])
plt.mrCA(ac)
library(MultiResponseR)
library(MultiResponseR)
require(ClustBlock)
data(straw)
dset=NULL
for (i in seq(1,(ncol(straw)-15),by=16)){
s=which(seq(1,(ncol(straw)-15),by=16)==i)
droit=straw[,i:(i+15)]
subject=rep(paste("S",s,sep="_"),nrow(droit))
product=rownames(droit)
ajout=cbind.data.frame(subject,product,droit)
dset=rbind.data.frame(dset,ajout)
}
dset$subject=as.factor(dset$subject)
dset$product=as.factor(dset$product)
cell=sensory.mr.sig.cell(dset,ncores = 8)
cell=sensory.mr.sig.cell(dset,ncores = 8,nbaxes.sig=1)
cell=sensory.mr.sig.cell(dset,ncores = 8,nbaxes.sig=1)
require(MultiResponseR)
dset
data(milkchoc)
res=sensory.mr.sig.cell(milkchoc,nbaxes.sig=1,ncores = 8)
plt.mr.sig.cell(res)
ac=mrCA(milkchoc[,-1])
plt.mrCA(ac)
res$p.value
library(MultiResponseR)
library(MultiResponseR)
sensory.mr.sig.cell()
sensory.mr.sig.cell
?person
library(MultiResponseR)
require(dplyr)
?setequal
library(MultiResponseR)
?data_frame
usethis::use_package_doc()
?devtools::document()
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
usethis::use_package_doc()
library(MultiResponseR)
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
library(MultiResponseR)
devtools::document()
library(MultiResponseR)
?`MultiResponseR-package`
library(MultiResponseR)
